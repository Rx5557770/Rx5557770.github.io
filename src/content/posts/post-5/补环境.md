
---
title: JS补环境
published: 2025-10-23
description: 什么？你还不会JS补环境？
image: ''
tags: ['code', 'js补环境', 'js']
category: 代码日常
draft: false
lang: zh-CN
---
    补环境主要是补**DOM**和**BOM**，一些nodejs没有的属性啊之类。关于 Proxy 对象用来补环境是很方便的，例如监听了window对象，那么运行一些混淆的代码，就能判断该方法做了什么改变。当混淆的js想要获取window的某个属性，就可以通过拦截然后输出到控制台，然后我们可以补下来。

## 环境检测代码

标准代码1
```js
const proxy = new Proxy(obj, {
  get(target, prop) {
    console.log("方法:Get ||", "对象", obj, "属性", prop, "值:", target[prop]);
    return target[prop];
  },

  set(target, prop, value) {
    console.log("方法:Set ||", "对象", obj, "属性", prop, "修改值:", value);
    target[prop] = value;
    return true;
  },
});
```

代码2

```js
proxy_ = function (func){
    return new Proxy(func, {
        set(target, key, value,){
            console.table([{'类型': 'set', '调用者': target, '调用属性': key, '调用值': value}])
            return Reflect.set(...arguments)
        },
        get(target, key, ){
            console.table([{'类型': 'get', '调用者': target, '调用属性': key, '调用值': target[key]}])
            return target[key]
        }
    })
}

window = this
window = proxy_(window)
```

完整代码

```js
/* type 1*/
function InterceptorArray(ObjArray) { // 接收变量名的字符串数组
    // 定义一个你想剔除的属性名黑名单
    const blacklistProperties = [
        'cookie',
    ];
    for (const name of ObjArray) {
        const obj = eval(name); // 获取原对象
        const proxy = new Proxy(obj, {
            get(target, prop) {
				// 检查当前访问的属性是否在黑名单中
            if (blacklistProperties.includes(prop)) {
                // 如果在黑名单中，直接返回属性值，不打印日志
                return target[prop];
            }
                console.log("方法:Get ||","对象", name, '属性', prop, '值:', target[prop]);
                return target[prop];
            },
            set(target, prop, value) {
                // console.log("方法:Set ||","对象", name, '属性', prop, '修改值:', value);
                target[prop] = value;
                return true;
            }
        });
        eval(`${name} = proxy`); // 替换原变量
    }
}

InterceptorArray(['window', 'document', 'navigator', 'location', 'screen', 'history', 'localStorage']); // 传入变量名的字符串数组


/* type 2*/

// 监控函数
var handlerProxy = function(o, name){
    // 定义一个你想剔除的属性名黑名单
    const blacklistProperties = [
        'cookie',

    ];
    return new Proxy(o, {
        set(target, property, value){
            // debugger;
            // 如果你想监控 set 操作，可以在这里添加条件过滤
            //console.log("Set--对象:",name,'属性:', property,'值:',value);
            return Reflect.set(...arguments);
        },
        get(target, property, receiver){
            // 检查当前访问的属性是否在黑名单中
            if (blacklistProperties.includes(property)) {
                // 如果在黑名单中，直接返回属性值，不打印日志
                return target[property];
            }
            console.log("Get--对象:", name, '属性:', property, '值:', target[property]);
            return target[property];
        }
    });
}
// 对象监控
window = handlerProxy(window, 'window')
document = handlerProxy(document, 'document')
navigator = handlerProxy(navigator, 'navigator')
screen = handlerProxy(screen, 'screen')
location = handlerProxy(location, 'location')
history = handlerProxy(history, 'history')
localStorage = handlerProxy(localStorage, 'localStorage')
```

## 检测对象
#### 基础框架

```js
let setProxyArr = function (proxyObjArr) {
  for (let i = 0; i < proxyObjArr.length; i++) {
    const handler = `{
    get:function(target,property,receiver){
    console.log("方法:","get","对象","${proxyObjArr[i]}","属性:",
property,"属性类型:",typeof property,"属性值:",target[property],"属性值类型:",typeof target[property]);
return Reflect.get(...arguments)
debugger
    },
    set:function(target,property,value,receiver){
    console.log("方法:","set","对象:","${proxyObjArr[i]}","属性:",
property,"属性类型:",typeof property,"属性值:",value,"属性值类型:",typeof target[property]);
    return Reflect.set(...arguments);
    }
  }`;
    eval(`try{
        ${proxyObjArr[i]};
        ${proxyObjArr[i]} = new Proxy(${proxyObjArr[i]},${handler});
        } catch (e){
         ${proxyObjArr[i]} = {};
         ${proxyObjArr[i]} = new Proxy(${proxyObjArr[i]},${handler});
         }`);
  }
}
var handlerProxy = function(o, name){
    // 定义一个你想剔除的属性名黑名单
    const blacklistProperties = [
      'WebAssembly'
        

    ];
    return new Proxy(o, {
        set(target, property, value){
            // debugger;
            // 如果你想监控 set 操作，可以在这里添加条件过滤
            //console.log("Set--对象:",name,'属性:', property,'值:',value);
            return Reflect.set(...arguments);
        },
        get(target, property, receiver){
            // 检查当前访问的属性是否在黑名单中
            if (blacklistProperties.includes(property)) {
                // 如果在黑名单中，直接返回属性值，不打印日志
                return target[property];
            }
            console.log("Get--对象:", name, '属性:', property, '值:', target[property]);
            return target[property];
        }
    });
}
const safeFunction = function safeFunction(func) {
  //处理安全函数
  Function.prototype.$call = Function.prototype.call;
  const $toString = Function.toString;
  const myFunction_toString_symbol = Symbol('('.concat('', ')'));

  const myToString = function myToString() {
    return typeof this === 'function' && this[myFunction_toString_symbol] || $toString.$call(this);
  }

  const set_native = function set_native(func, key, value) {
    Object.defineProperty(func, key, {
      "enumerable": false,
      "configurable": true,
      "writable": true,
      "value": value
    });
  }

  delete Function.prototype['toString'];
  set_native(Function.prototype, "toString", myToString);
  set_native(Function.prototype.toString, myFunction_toString_symbol, "function toString() { [native code] }");

  const safe_Function = function safe_Function(func) {
    set_native(func, myFunction_toString_symbol, "function" + (func.name ? " " + func.name : "") + "() { [native code] }");
  }

  return safe_Function(func)
}

/* 常用的检测点 */
window = global;
window.self = window;
window.window = window;
// 删除nodejs特征
delete global;
delete Buffer;



// 基础框架
EventTarget = function EventTarget(){}
EventTarget.prototype.addEventListener = function(){}
EventTarget.prototype.removeEventListener = function(){}
EventTarget.prototype.dispatchEvent = function(){}
EventTarget.prototype.toString = () => '[object EventTarget]'

WindowProperties = function WindowProperties() {}
WindowProperties.prototype.toString = () => '[object WindowProperties]'

Window = function Window(){}
Window.prototype.toString = () => '[object Window]'
Object.setPrototypeOf(Window.prototype, WindowProperties.prototype);
Object.setPrototypeOf(WindowProperties.prototype, EventTarget.prototype);
Object.setPrototypeOf(window, Window.prototype)


Element = function Element(){}
Document = function Document(){}
Document.prototype.toString = () => '[object Document]'
HTMLDocument = function HTMLDocument(){}
HTMLDocument.prototype.toString = () => '[object HTMLDocument]'
HTMLDocument.prototype.createElement = function createElement(res){
        console.log('createElement:::', res)
        if(res == 'canvas'){
            return canvas
        }
}
HTMLDocument.prototype.getElementById = function getElementById(id){
    console.log('getElementById:::', id)
}
HTMLDocument.prototype.getElementsByClassName = function getElementsByClassName(name){
    console.log("getElementsByClassName:::", name)
}
Object.setPrototypeOf(HTMLDocument.prototype, Document.prototype)
Object.setPrototypeOf(Document.prototype, EventTarget.prototype)

HTMLCanvasElement = function HTMLCanvasElement(){}
HTMLCanvasElement.prototype.toString = () => '[object HTMLCanvasElement]'
Object.setPrototypeOf(HTMLCanvasElement.prototype, Element.prototype)


Navigator = function Navigator(){}
Navigator.prototype.toString = () => '[object Navigator]'
Navigator.prototype.appCodeName = "Mozilla"
Navigator.prototype.appName = "Netscape"
Navigator.prototype.userAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 QuarkPC/4.1.7.408"
Navigator.prototype.appVersion = "5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 QuarkPC/4.1.7.408"
Navigator.prototype.webdriver = false

Location = function Location(){}
Location.prototype.toString = () => '[object Location]'

Screen = function Screen(){}
Screen.prototype.toString = () => '[object Screen]'
Screen.prototype.availWidth = 1536
Screen.prototype.availHeight = 816


History = function History(){}
History.prototype.toString = () => '[object History]'

Storage = function Storage(){}
Storage.prototype.toString = () => '[object Storage]'
Storage.prototype.getItem = function getItem(){}
Storage.prototype.setItem = function setItem(){}


XMLHttpRequest = function XMLHttpRequest() {};
XMLHttpRequest.prototype.toString = () => '[object XMLHttpRequest]'
XMLHttpRequest.prototype.open = function() {};
XMLHttpRequest.prototype.send = function() {};

Window.prototype[Symbol.toStringTag] = 'Window';
Navigator.prototype[Symbol.toStringTag] = 'Navigator';
Location.prototype[Symbol.toStringTag] = 'Location';
History.prototype[Symbol.toStringTag] = 'History';
Screen.prototype[Symbol.toStringTag] = 'Screen';
Storage.prototype[Symbol.toStringTag] = 'Storage';
HTMLDocument.prototype[Symbol.toStringTag] = 'HTMLDocument';
Element.prototype[Symbol.toStringTag] = 'Element';
HTMLCanvasElement.prototype[Symbol.toStringTag] = 'HTMLCanvasElement';
Event.prototype[Symbol.toStringTag] = 'Event';
XMLHttpRequest.prototype[Symbol.toStringTag] = 'XMLHttpRequest';
Blob.prototype[Symbol.toStringTag] = 'Blob';
File.prototype[Symbol.toStringTag] = 'File';
URL.prototype[Symbol.toStringTag] = 'URL';
Promise.prototype[Symbol.toStringTag] = 'Promise';
Map.prototype[Symbol.toStringTag] = 'Map';
Set.prototype[Symbol.toStringTag] = 'Set';
Document.prototype[Symbol.toStringTag] = 'HTMLDocument';

document = new HTMLDocument();
navigator = new Navigator();
location = new Location();
screen = new Screen();
history = new History();
localStorage = new Storage();


document.documentElement = {
  nodeName: 'HTML',
  tagName: 'HTML',
  parentNode: document,
};

window.document = document
window.navigator = navigator
window.screen = screen
window.history = history
window.localStorage = localStorage
window.location = location
window.toString = () => '[object Window]'
window.MouseEvent = function(){}

safeFunction(EventTarget.prototype.addEventListener)
safeFunction(EventTarget.prototype.removeEventListener)
safeFunction(EventTarget.prototype.dispatchEvent)
safeFunction(HTMLDocument.prototype.createElement)
safeFunction(HTMLDocument.prototype.getElementById)
safeFunction(HTMLDocument.prototype.getElementsByClassName)
safeFunction(Storage.prototype.getItem)
safeFunction(Storage.prototype.setItem)
safeFunction(XMLHttpRequest)

// 对象监控
window = handlerProxy(window, 'window')
document = handlerProxy(document, 'document')
navigator = handlerProxy(navigator, 'navigator')
screen = handlerProxy(screen, 'screen')
location = handlerProxy(location, 'location')
history = handlerProxy(history, 'history')
localStorage = handlerProxy(localStorage, 'localStorage')
```

#### 不常见的检测

```js
/* document.all检测 */
const v8 = require("v8");
const vm = require("vm");

// 允许使用 V8 内置函数（需启用 --allow-natives-syntax 标志）
v8.setFlagsFromString('--allow-natives-syntax');

// 创建不可检测对象
let undetectable = vm.runInThisContext('%GetUndetectable()');

// 恢复标志禁用（可选）
v8.setFlagsFromString('--no-allow-natives-syntax');


function HTMLAllCollection() {
    return undetectable
};
Object.defineProperties(HTMLAllCollection.prototype, {
    [Symbol.toStringTag]: {
        value: 'HTMLAllCollection',
        configurable: true
    }
});
undetectable.__proto__ = HTMLAllCollection.prototype;
document = {}
document.all = new HTMLAllCollection()

length = 3;
for (let i = 0; i < length; i++) {
    document.all[i] = '1';
}
document.all.length = length;
// console.log(typeof document.all)
// console.log(document.all)
// console.log(document.all.length)
```


```js
// 实现增加属性值的内容
function createAppendableObject(target = {}, options = {}) {
  const { autoArray = false } = options;
  
  return new Proxy(target, {
    /**
     * 拦截属性设置操作
     * @param {Object} target - 目标对象
     * @param {string|Symbol} property - 属性名
     * @param {any} value - 要设置的值
     * @param {Object} receiver - Proxy 或继承 Proxy 的对象
     * @returns {boolean} 返回 true 表示成功
     */
    set(target, property, value, receiver) {
      // 检查属性是否已存在
      const exists = Reflect.has(target, property);
      
      if (exists) {
        const currentValue = Reflect.get(target, property, receiver);
        
        // 处理不同类型的追加逻辑
        if (Array.isArray(currentValue)) {
          // 已经是数组，直接追加
          currentValue.push(value);
        } else if (autoArray) {
          // 自动转换为数组模式
          Reflect.set(target, property, [currentValue, value], receiver);
        } else if (typeof currentValue === 'string') {
          // 字符串连接
          Reflect.set(target, property, currentValue + value, receiver);
        } else if (typeof currentValue === 'number') {
          // 数字相加
          Reflect.set(target, property, currentValue + value, receiver);
        } else {
          // 其他类型转换为数组
          Reflect.set(target, property, [currentValue, value], receiver);
        }
      } else {
        // 属性不存在，直接设置
        Reflect.set(target, property, value, receiver);
      }
      
      return true;
    },
    
    /**
     * 拦截属性获取操作
     * @param {Object} target - 目标对象
     * @param {string|Symbol} property - 属性名
     * @param {Object} receiver - Proxy 或继承 Proxy 的对象
     * @returns {any} 返回属性值
     */
    get(target, property, receiver) {
      // 特殊处理 'toJSON' 属性，确保 JSON.stringify 正常工作
      if (property === 'toJSON') {
        return () => target;
      }
      return Reflect.get(target, property, receiver);
    }
  });
}

document = createAppendableObject();
document.cookie = 'a1=a1' + '; '
document.cookie = 'a2=a2' + '; '
console.log(document.cookie)
```